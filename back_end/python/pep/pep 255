제네레이터 

* 제네레이터 개념과 yield문 소개


생산자 함수가 생성된 값 사이의 상태를 유지해야 하는 작업을 충분히 행해야 하는 경우, 대부분의 프로그래밍 언어는 생산자 파라미터에 콜백 함수를 추가하여 생산된 값을 호출 할수 있도록 솔루션을 제공했다. (일반적인 방법)


만일 프로그램 전체 구문을 큰 목록으로 만들어 로컬변수를 제어하는 방식인 기존으로 방식으로 할수도 있지만, 이는 전체 구문과 변수의 크기가 클경우 메모리의 낭비가 될수 있다. (1조개의 리스트를 만든다고 생각해보자. 해당 변수가 메모리에 모두 올라가야 한다면?)

다른 대안으로 .next()메소드가 호출될 때마다 다음 프로세스를 호출 하는 것이다. 이것은 많은 결과 목록과 방식을 호출자에게 전달할수 있으며, 다음의 값을 기억할 필요도 없다. 단점은 .next() 호출 사이의 상태값을 기억하고 있어야 한다. 

또 다른 대안으로 진행 프로세스 호출을 스레드에서 실행하는 것이다. 이는 자연스럽게 상태를 유지 한다. 하지만 스레드가 없는 플렛폼에서는 문제가 될수 있다. 

마지막 대안으로 경량 코루틴을 지원할수 있다. 이는 스레드 옵션과 프로그래밍 방식이 비슷하지만 훨씬 효율적이다. 그러나 스택리스(stackless)는 파이썬 코어에 대한 논라의 여지가 있으며, 자이썬등의 다른 인터프린터에서 구현이 불가능 할수 있다. 

이에 대한 솔루션으로 반복자에 영감을 받아 제네레이터 표현을 구현.


def fib():
    a, b = 0, 1
    while 1:
       yield b
       a, b = b, a+b

호출자의 관점에서 볼 때 fib 호출은 원하는대로 다시 시작할 수있는 반복 가능한 개체이다. 스레드 접근 방식에서와 같이 가장 자연스러운 방식으로 코딩 할 수 있습니다. 그러나 스레드 접근 방식과 달리 모든 플랫폼에서 효율적으로 수행 할 수 있다.

Python generator is a kind of Python iterator


yield
yield is a new keyword, so a future statement is needed to phase this in: in the initial release, a module desiring to use generators must include the line:

제네레이터 함수가 호출 될 때, 실제 인수는 일반적인 방법으로 기능을 로컬 형식 인수 이름에 바인딩되어 있지만, 함수의 몸에 어떤 코드가 실행되지 않다. 대신 제네레이터 반복자 객체가 돌려준다. 이는 반복자 프로토콜를  준수 하므로 특히 자연스럽게 for 루프에서 사용될 수 있다



Exception


StopIteration 을 포함하지만 이에 국한되지 않는 처리되지 않은 예외 가 발생기 함수에 의해 발생되거나이를 통과하는 경우, 예외는 일반적인 방식으로 호출자에게 전달되고 이후에 발생기 함수를 재개하려고 시도합니다. StopIteration을 raise 하면 된다. 

>>> def f():
...     try:
...         yield 1
...         try:
...             yield 2
...             1/0
...             yield 3  # never get here
...         except ZeroDivisionError:
...             yield 4
...             yield 5
...             raise
...         except:
...             yield 6
...         yield 7     # the "raise" above stops this
...     except:
...         yield 8
...     yield 9
...     try:
...         x = 12
...     finally:
...        yield 10
...     yield 11
>>> print list(f())
[1, 2, 4, 5, 8, 9, 10, 11]
>>>
