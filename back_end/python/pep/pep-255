함수의 진행중  생성된 값과 진행 상태를 유지해야 하는 작업있다. 이때 생성된 값을 호출할 수 있는 기능은 제공하고 있지 않다.


예를 들어 표준 라이블러리인 tokenize.py는 tokenize()가 다음 토큰을 찾을때마다 호출되는 tokeneat()에 tokeneater 함수를 전달해야 한다.  
이를 통해 자연스럽게 토큰 화를 코딩 할 수 있지만, 토큰 화를 호출하는 프로그램은 일반적으로 마지막에 표시된 토큰을 콜백간에 기억할 필요가 있다. 
tokeneater의 함수 tabnanny.py이는 전역 변수로 상태 머신을 유지하면서 콜백 전반에 걸쳐 이미 본 내용과 다음에 볼 내용을 기억하는 좋은 예이다. 
하지만 이는 올바르게 작동하기 어려우며, 이해하기 어려운 방법이다. 

또 다른 대안은 .next()메소드가 호출될 때마다 다음 토큰을 전달하여 iterator를 토큰화 하는 것이다. 이 방법은 호출자에게는 명쾌하지만, 
초기화를 한다거나, 호출사이의 상태를 기억하기 위해서는 부담이 가는 방법이다. 

다른 옵션은 생산자와 소비자 별도의 스레드를 실행하는 것이다. 이를 통해 상태를 유지 할수 있지만, 스레드가 없는 플랫폼에서는 작동하지 않으며,
다른 플랫폼에 비해 느릴수 있다. 

현재 대안은 중간 결과에서 다음값을 호출자에게 리턴 할 수 있고, 함수를 다시 시작할 수 있도록 함수의 로컬 상태를 유지하는 일종의 함수를 제공 한다. 

def fib():
    a, b = 0, 1
    while 1:
       yield b
       a, b = b, a+b

yield의 까지의 상태는 그래도 저장되며, yield의 값을 제공한다. Fid호출은 반복할 수 있으며, 다시 시작할 수 도 있다. 

from __future__ import generators

모듈 경고 트리거의 자세한 사항은 pep-236에 참조.

yield문은 함수안에서만 사용할 수 있으며, 제네레이터 함수라 한다. 

제네레이터 함수는 일반 함수와 같지만 co_flags, CO_GENERATOR의 플래그가 설정되어 있다. 
제네레이터 함수가 실행 되면 해당 인수가 로컬 형식으로 바인딩 되며, 반복자 프로토콜을 준수하므로 for 루프를 사용할수 있다. 

제한사항 - 제네레이터가 활성 상태인 경우에도 next()는 사용할 수 없다. 

>>> def g():
...     i = me.next()
...     yield i
>>> me = g()
>>> me.next()
Traceback (most recent call last):
 ...
 File "<string>", line 2, in g
ValueError: generator already executing


return
Try except에서 
>>> def f1():
...     try:
...         return
...     except:
...        yield 1
>>> print list(f1())
[]


>>> def f2():
...     try:
...         raise StopIteration
...     except:
...         yield 42
>>> print list(f2())
[42]
