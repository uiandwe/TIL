제네레이터 

* 제네레이터 개념과 yield문 소개


생산자 함수가 생성된 값 사이의 상태를 유지해야 하는 작업을 충분히 행해야 하는 경우, 대부분의 프로그래밍 언어는 생산자 파라미터에 콜백 함수를 추가하여 생산된 값을 

호출 할수 있도록 솔루션을 제공했다. (일반적인 방법)


만일 프로그램 전체 구문을 큰 목록으로 만들어 로컬변수를 제어하는 방식인 기존으로 방식으로 할수도 있지만, 이는 전체 구문과 변수의 크기가 클경우 메모리의 낭비가 

될수 있다. (1조개의 리스트를 만든다고 생각해보자. 해당 변수가 메모리에 모두 올라가야 한다면?)

다른 대안으로 .next()메소드가 호출될 때마다 다음 프로세스를 호출 하는 것이다. 이것은 많은 결과 목록과 방식을 호출자에게 전달할수 있으며, 다음의 값을 기억할 

필요도 없다. 단점은 .next() 호출 사이의 상태값을 기억하고 있어야 한다. 

또 다른 대안으로 진행 프로세스 호출을 스레드에서 실행하는 것이다. 이는 자연스럽게 상태를 유지 한다. 하지만 스레드가 없는 플렛폼에서는 문제가 될수 있다. 

마지막 대안으로 경량 코루틴을 지원할수 있다. 이는 스레드 옵션과 프로그래밍 방식이 비슷하지만 훨씬 효율적이다. 그러나 스택리스(stackless)는 파이썬 코어에 대한 

논라의 여지가 있으며, 자이썬등의 다른 인터프린터에서 구현이 불가능 할수 있다. 이에 대한 솔루션으로 반복자에 영감을 받아 제네레이터 표현을 구현.




함수의 진행중  생성된 값과 진행 상태를 유지해야 하는 작업있다. 이때 생성된 값을 호출할 수 있는 기능은 제공하고 있지 않다.


예를 들어 표준 라이블러리인 tokenize.py는 tokenize()가 다음 토큰을 찾을때마다 호출되는 tokeneat()에 tokeneater 함수를 전달해야 한다.  
이를 통해 자연스럽게 토큰 화를 코딩 할 수 있지만, 토큰 화를 호출하는 프로그램은 일반적으로 마지막에 표시된 토큰을 콜백간에 기억할 필요가 있다. 
tokeneater의 함수 tabnanny.py이는 전역 변수로 상태 머신을 유지하면서 콜백 전반에 걸쳐 이미 본 내용과 다음에 볼 내용을 기억하는 좋은 예이다. 
하지만 이는 올바르게 작동하기 어려우며, 이해하기 어려운 방법이다. 

또 다른 대안은 .next()메소드가 호출될 때마다 다음 토큰을 전달하여 iterator를 토큰화 하는 것이다. 이 방법은 호출자에게는 명쾌하지만, 
초기화를 한다거나, 호출사이의 상태를 기억하기 위해서는 부담이 가는 방법이다. 

다른 옵션은 생산자와 소비자 별도의 스레드를 실행하는 것이다. 이를 통해 상태를 유지 할수 있지만, 스레드가 없는 플랫폼에서는 작동하지 않으며,
다른 플랫폼에 비해 느릴수 있다. 

현재 대안은 중간 결과에서 다음값을 호출자에게 리턴 할 수 있고, 함수를 다시 시작할 수 있도록 함수의 로컬 상태를 유지하는 일종의 함수를 제공 한다. 

호출자의 관점에서 볼 때 fib 호출은 원하는대로 다시 시작할 수있는 반복 가능한 개체이다. 스레드 접근 방식에서와 같이 가장 자연스러운 방식으로 코딩 할 수 있습니다.

그러나 스레드 접근 방식과 달리 모든 플랫폼에서 효율적으로 수행 할 수 있다.

Python generator is a kind of Python iterator



yield

yield is a new keyword, so a future statement is needed to phase this in: in the initial release, 

a module desiring to use generators must include the line:


def fib():
    a, b = 0, 1
    while 1:
       yield b
       a, b = b, a+b

yield의 까지의 상태는 그래도 저장되며, yield의 값을 제공한다. Fid호출은 반복할 수 있으며, 다시 시작할 수 도 있다. 

from __future__ import generators

모듈 경고 트리거의 자세한 사항은 pep-236에 참조.

yield문은 함수안에서만 사용할 수 있으며, 제네레이터 함수라 한다. 

제네레이터 함수는 일반 함수와 같지만 co_flags, CO_GENERATOR의 플래그가 설정되어 있다. 
제네레이터 함수가 실행 되면 해당 인수가 로컬 형식으로 바인딩 되며, 반복자 프로토콜을 준수하므로 for 루프를 사용할수 있다. 

제한사항 - 제네레이터가 활성 상태인 경우에도 next()는 사용할 수 없다. 

>>> def g():
...     i = me.next()
...     yield i
>>> me = g()
>>> me.next()
Traceback (most recent call last):
 ...
 File "<string>", line 2, in g
ValueError: generator already executing


return
Try except에서 
>>> def f1():
...     try:
...         return
...     except:
...        yield 1
>>> print list(f1())
[]


>>> def f2():
...     try:
...         raise StopIteration
...     except:
...         yield 42
>>> print list(f2())
[42]
